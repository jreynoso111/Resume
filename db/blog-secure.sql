-- ============================================================
-- Blog tables + RLS + demo seed (Supabase)
-- Public read, admin-only writes (by Auth email via public.is_admin()).
--
-- Run this in Supabase SQL Editor for your project.
-- ============================================================

-- Helpers (safe to re-run)
create or replace function public.set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

create or replace function public.is_admin()
returns boolean
language sql
stable
as $$
  select lower(coalesce(auth.jwt() ->> 'email', '')) = 'jreynoso111@gmail.com'
$$;

-- Tables
create table if not exists public.blog_posts (
  id bigint generated by default as identity primary key,
  slug text not null,
  title text not null,
  excerpt text,
  cover_image_url text,
  is_published boolean not null default true,
  published_at timestamptz,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

drop trigger if exists set_blog_posts_updated_at on public.blog_posts;
create trigger set_blog_posts_updated_at
before update on public.blog_posts
for each row execute function public.set_updated_at();

create unique index if not exists blog_posts_slug_key
on public.blog_posts (slug);

create table if not exists public.blog_chapters (
  id bigint generated by default as identity primary key,
  post_id bigint not null references public.blog_posts(id) on delete cascade,
  title text not null,
  body text,
  image_url text,
  sort_order integer not null default 0,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

drop trigger if exists set_blog_chapters_updated_at on public.blog_chapters;
create trigger set_blog_chapters_updated_at
before update on public.blog_chapters
for each row execute function public.set_updated_at();

create unique index if not exists blog_chapters_post_sort_key
on public.blog_chapters (post_id, sort_order);

create index if not exists blog_chapters_post_id_idx
on public.blog_chapters (post_id);

-- Grants (RLS still applies)
grant usage on schema public to anon, authenticated;
grant select on public.blog_posts to anon, authenticated;
grant select on public.blog_chapters to anon, authenticated;
grant insert, update, delete on public.blog_posts to authenticated;
grant insert, update, delete on public.blog_chapters to authenticated;
grant usage, select, update on all sequences in schema public to authenticated;

-- RLS
alter table public.blog_posts enable row level security;
alter table public.blog_chapters enable row level security;

-- Public read: only published posts
drop policy if exists blog_posts_public_read on public.blog_posts;
create policy blog_posts_public_read on public.blog_posts
for select to anon, authenticated
using (is_published = true);

drop policy if exists blog_posts_admin_read on public.blog_posts;
create policy blog_posts_admin_read on public.blog_posts
for select to authenticated
using (public.is_admin());

drop policy if exists blog_chapters_public_read on public.blog_chapters;
create policy blog_chapters_public_read on public.blog_chapters
for select to anon, authenticated
using (
  exists (
    select 1
    from public.blog_posts p
    where p.id = blog_chapters.post_id
      and p.is_published = true
  )
);

drop policy if exists blog_chapters_admin_read on public.blog_chapters;
create policy blog_chapters_admin_read on public.blog_chapters
for select to authenticated
using (public.is_admin());

-- Admin writes (authenticated + email match)
drop policy if exists blog_posts_admin_insert on public.blog_posts;
create policy blog_posts_admin_insert on public.blog_posts
for insert to authenticated
with check (public.is_admin());

drop policy if exists blog_posts_admin_update on public.blog_posts;
create policy blog_posts_admin_update on public.blog_posts
for update to authenticated
using (public.is_admin())
with check (public.is_admin());

drop policy if exists blog_posts_admin_delete on public.blog_posts;
create policy blog_posts_admin_delete on public.blog_posts
for delete to authenticated
using (public.is_admin());

drop policy if exists blog_chapters_admin_insert on public.blog_chapters;
create policy blog_chapters_admin_insert on public.blog_chapters
for insert to authenticated
with check (public.is_admin());

drop policy if exists blog_chapters_admin_update on public.blog_chapters;
create policy blog_chapters_admin_update on public.blog_chapters
for update to authenticated
using (public.is_admin())
with check (public.is_admin());

drop policy if exists blog_chapters_admin_delete on public.blog_chapters;
create policy blog_chapters_admin_delete on public.blog_chapters
for delete to authenticated
using (public.is_admin());

-- Seed demo content (safe to re-run).
with post_row as (
  insert into public.blog_posts (slug, title, excerpt, cover_image_url, is_published, published_at)
  values (
    'first-post',
    'First Post (Demo)',
    'Generic post to test the blog end-to-end: list view, post detail with chapters and images, and editing from the dashboard.',
    'assets/images/blog/cover-generic.png',
    true,
    now()
  )
  on conflict (slug) do update set
    title = excluded.title,
    excerpt = excluded.excerpt,
    cover_image_url = excluded.cover_image_url,
    is_published = excluded.is_published
  returning id
)
insert into public.blog_chapters (post_id, sort_order, title, body, image_url)
select
  post_row.id,
  v.sort_order,
  v.title,
  v.body,
  v.image_url
from post_row
cross join (
  values
    (0, 'Chapter 1: Structure', E'This is a generic chapter.\n\nIt includes a text block and an image area.', 'assets/images/blog/chapter-1.png'),
    (1, 'Chapter 2: Images', E'Images can be local paths (assets/...) or public URLs from Supabase Storage.\n\nFrom the dashboard you can upload an image and save its URL on the chapter.', 'assets/images/blog/chapter-2.png'),
    (2, 'Chapter 3: Publishing', E'You can publish the post or keep it as a draft.\n\nVisitors only see published posts.', 'assets/images/blog/chapter-3.png')
) as v(sort_order, title, body, image_url)
on conflict (post_id, sort_order) do update set
  title = excluded.title,
  body = excluded.body,
  image_url = excluded.image_url;

